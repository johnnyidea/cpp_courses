
Как решить проблему дублирования кода? В Си использовались макросы. У плюсов же шаблоны. 
Чем шаблоны лучше - проверкой синтаксиса, и проще определять.

Также можно при объявлениие ф-ции или класса с шаблоном задавать дефотный тип, к примеру 
template<class T, class B = int, class R = Boo>
void foo (){..}.

Для того, чтобы не было так грамоздко, использовать typedef

typedef Array<float, int, Boo const &> FIB;

вызов: FIB foo();

---

##Задача 2

В предыдущей версии предполагается, что для типа T определены оператор присваивания и конструктор по умолчанию.
При создании шаблонных классов контейнеров (вроде Array и не только) разумно стараться минимизировать требования
к типам шаблонных параметров. Поэтому усложним задачу, реализуйте класс Array не полагаясь на то, что для типа T
определен оператор присваивания и конструктор по умолчанию. Конструктор копирования у типа T есть.
<br>
Hints: используйте placement new и явный вызов деструктора (смотрите урок 3.4), чтобы создавать и уничтожать объекты,
аллоцировать правильно выровненную память можно с помощью new char[N * sizeof(T)], где N - количество элементов массива.

Итак, отсутствие у типа T перегруженного оператора '=' и дефолтного конструктора, т.е.
нельзя: 
* _data[i] = array._data[i];
* const T& value = T()

Выводы по второй задаче:
- если шаблонный тип не имеет дефолтного конструктора, а, поскольку data - это указатель на массив, это значит что для каждого отдельного 
элемента необходимо выделять память в куче с помощью new. При всем этом необходимо явно приводить к типу T(), т.е. в цикле:
  new(_data+i)T(array._data[i]));
- при инициализации _data необходимо выделять память по особому, через static_cast, т.е.:
T * _data = static_cast<T*>(operator new [](size * sizeof(T)))
- удаление также хитрее чем кажется. Сперва нужно посмотреть не 1-й пункт и понять, как удалить каждый веделенный элемент (в цикле, вызывая
  дестуктор для каждого эл-а e.g. _data[i].~T()), Во-вторый, необходимо удалить указатель на массив _data явно приведя к char *, т.е.
  delete[] (char*) _data;

---

####Ссылка на используемый метод:
https://ru.wikipedia.org/wiki/New_(C%2B%2B)#Placement_new%EF%BB%BF

###Метод Placement new.
Особая форма оператора new.
<br>
Главное: 
- не выделяет память, а использует имеющуюся;
- пригоден для тех типов, у которых отсутствует дефолтный конструктор;
- используется для массивов.

полезные ссылки:
  - ru.wikipedia.org/wiki/Куча_(память)
  - ru.wikipedia.org/wiki/Динамическое_распределение_памяти


##Задача 3
Использование шаблонного класса, который унаследован от интерфейса.
Суть: перегрузить метод интерфейса clone, суть которого сделать копию объекта, созданную в куче.
решение: выделить память в куче через new. Выделяем с помощью конструктора, передав указатель на текущий класс.
