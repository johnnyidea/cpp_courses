Как решить проблему дублирования кода? В Си использовались макросы. У плюсов же шаблоны. 
Чем шаблоны лучше - проверкой синтаксиса, и проще определять.

Также можно при объявлениие ф-ции или класса с шаблоном задавать дефотный тип, к примеру 
template<class T, class B = int, class R = Boo>
void foo (){..}.

Для того, чтобы не было так грамоздко, использовать typedef

typedef Array<float, int, Boo const &> FIB;

вызов: FIB foo();

---

Задача 2

В предыдущей версии предполагается, что для типа T определены оператор присваивания и конструктор по умолчанию.
При создании шаблонных классов контейнеров (вроде Array и не только) разумно стараться минимизировать требования
к типам шаблонных параметров. Поэтому усложним задачу, реализуйте класс Array не полагаясь на то, что для типа T
определен оператор присваивания и конструктор по умолчанию. Конструктор копирования у типа T есть.
<br>
Hints: используйте placement new и явный вызов деструктора (смотрите урок 3.4), чтобы создавать и уничтожать объекты,
аллоцировать правильно выровненную память можно с помощью new char[N * sizeof(T)], где N - количество элементов массива.

Итак, отсутствие у типа T перегруженного оператора '=' и дефолтного конструктора, т.е.
нельзя: 
* _data[i] = array._data[i];
* const T& value = T()

но можно 
* T t_old(t_new);
