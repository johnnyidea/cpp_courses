##Предисловия 
###Задача 1:
В разговоре о перегрузке операторов мы упомянули умные указатели. Это тема, которой стоит уделить отдельный урок.

На предыдущих неделях вы уже набили достаточно шишек на ручном управлении памятью. Пришло время задуматься о более разумном подходе. Начнем с довольно простого случая — рассмотрим динамические объекты, время жизни которых ограничено блоком ({} — ограничивают блок в C++). Указатель на такой динамический объект внутри блока можно "связать" со временем жизни объекта на стеке: достаточно сохранить этот указатель в некотором объекте на стеке, а в деструкторе этого объекта вызвать delete. Так как деструктор объекта, созданного на стеке, вызывается автоматически при выходе из блока, то delete тоже будет вызван автоматически.

Такой класс-обертку мы будем называть ScopedPtr. Стоит заметить, что копирование такого объекта может приводить к серьезным проблемам, например, к повторному освобождению памяти (два объекта хранят внутри один и тот же указатель и вызов delete будет сделан дважды). Поэтому нужно запретить вызов конструктора копирования и оператора присваивания таких объектов. Добиться этого можно объявив их в private секции класса. При этом даже не нужно их реализовывать — снаружи класса никто не сможет их вызвать, а внутри класса мы этого делать не будем.

Какой интерфейс может быть у такого класса ScopedPtr? Кроме уже известных вам операторов * и ->, деструктора и конструктора, полезными могут оказаться следующие методы:

- get — возвращает указатель, сохраненный внутри ScopedPtr (например, чтобы передать его в какую-то функцию);
- release — забирает указатель у ScopedPtr и возвращает значение этого указателя, после вызова release ScopedPtr не должен освобождать память (например, чтобы вернуть этот указатель из функции);
- reset — метод заставляет ScopedPtr освободить старый указатель, а вместо него захватить новый (например, чтобы переиспользовать ScopedPtr, так как оператор присваивания запрещен).

###Задача 2:
Для ScopedPtr мы запретили копирование, однако, копирование можно и разрешить. Это позволит реализовать более продвинутый умный указатель — SharedPtr. Он отличается от ScopedPtr тем, что кроме хранения указателя на объект, он хранит еще и счетчик ссылок (количество объектов SharedPtr, которые хранят один и тот же указатель).

Имея такой счетчик, мы можем определить момент, когда на объект, выделенный в куче, не останется больше ссылок (когда счетчик ссылок станет равным 0), и освободить память.

Поддержка счетчика ссылок состоит из нескольких частей:

- в конструкторе SharedPtr от ненулевого указателя мы инициализируем счетчик ссылок в 1 (конструктор создает первый SharedPtr, который хранит указатель),
- в конструкторе копирования мы увеличиваем счетчик ссылок на 1, если копируемый SharedPtr содержит ненулевой указатель (конструктор копирования создает еще один SharedPtr с указателем на тот же самый объект),
- в деструкторе мы уменьшаем значение счетчика на 1, если в объекте SharedPtr хранится ненулевой указатель (мы удаляем один SharedPtr, который указывает на объект в куче),
оператор присваивания уменьшает счетчик ссылок левого операнда на 1, если внутри левого SharedPtr хранится ненулевой указатель, увеличивает счетчик правого SharedPtr на 1, если в правом SharedPtr хранится ненулевой указатель (обычное дело для оператора присваивания — сначала освобождаем старые ресурсы, потом выделяем новые, но при этом нужно быть особенно внимательным с присваиванием самому себе).

Для класса SharedPtr могут оказаться полезными следующие методы (кроме операторов * и ->, конструктора копирования, оператора присваивания, деструктора и конструктора):
- метод get, как и в случае со ScopedPtr,
- метод reset — аналогичен reset у ScopedPtr, но освобождает память, только если счетчик ссылок после декремента равен 0.