Перегрузка операторов.
Для чего? - для определения поведения при использовании объектов класса.

Перегрузка операторов внутри/вне класса. 
Унарный - от нуля аргументов/ бинарный от одного или двух.

Метод - внутри класса, и соответсвенно внешняя функция.
Оператор + и * (Point const & v, double d) можно определить как метод, а * (double d, Point const & v) - нельзя, тк d - встроенный тип, поэтому данный метод нужно определить как внешнюю функцию.

Только внутри прегружаемые операторы: а) приведение (тип) б) [] в) () г) -> д) ->* e) =

Для перегрузки операторов инкремента/декремента в зависимости от типа(префиксный или постфиксный) используют уловку. Если хотим префиксный инк/дек то в качестве аргумента ничего не передаем. Если постфиксный то используем фиктивный параметр(заглушка). 
Пример для постфиксного:
Point & operator ++ (int)
{...}

Если меняем левый аргумент (например с помощь. +=), то логичнее использовать метод (тк this).

Также удобно делать следующий образом: определять бинарный операторы (-=, +=, *=, /=)  (с сигнатурой Point& operator+= (Point &left, const Point &right){...}), тк они меняют левый операнд, а уже потом, на основе уже определенных создавать обычный опреатора типа +-*/ во внешней функции.

Переопределения операторов сравнения - хорошим тоном является определения всех. Если написал ==, то будь добр, опредление также !=. Тоже самое с неравенствами. Достаточно определить лишь два, скажем равно и меньше, все остальнын выразить через них.

При перегрузке хотя бы 1 опреатор должен быть пользовательским.
